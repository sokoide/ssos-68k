# QuickDrawスタイル移行レビューと段階計画

## 1. 現状レビュー（2025年3月）
最近追加された QuickDraw スタイルのコードを確認した結果、以下の課題が判明しました。

- **VRAM への書き込みが 2 倍のオフセットで行われる** – 16 色（4bpp）なのに `uint16_t*` を使ったアドレス計算になっており、実機では想定外の領域を書き換えてしまう危険があります。
- **ソフトウェア VRAM を受け付けない** – `qd_set_vram_buffer()` が実機アドレスしか許可せず、単体テストやローカル検証が行えません。
- **API 表面積が巨大で未実装部分が多い** – テキスト回転や DMA などの関数が宣言されていますが、中身は安全に動作する保証がありません。段階移行を阻害するノイズになっています。
- **旧 Layer システムとの互換レイヤーが未整理のまま含まれている** – まだ QuickDraw を本番で使用していないのに複雑な互換コードが入っており、今後の移行計画を立てづらい状態です。

まずはこれらを解消し、「正しく動く最小の QuickDraw コア」を用意するところから始めます。

## 2. 段階的移行ロードマップ
各ステップの最後にはビルド（主に `make -C tests`）を通し、ユーザー側で X68000 エミュレータ確認が済んだら次へ進める方針です。

| ステップ | 目的 | 主要タスク | 検証 | 備考 |
|----------|------|------------|------|------|
| **1. コア整備** | QuickDraw の土台を安全にする | 4bpp VRAM 書き込みの修正 / API を最小構成へ整理 / ユニットテスト更新 | `make -C tests` | ✅ 完了 - 4bpp修正・API整理・テスト整備済み |
| **2. 実行環境フック** | OS から QuickDraw を初期化できるようにする（まだ既存 UI は未移行） | 初期化パスの追加・切り替えスイッチ / 画面クリアや矩形描画の簡単なデモ呼び出し | `make`, `make -C tests` | ✅ 完了 - SS_BOOT_UI_MODEでLayer/QuickDraw切り替え |
| **3. 個別コンポーネント移行** | まずは負荷の小さい UI 部分を QuickDraw に置き換える | 例：ステータスバーやメモリ表示ウィンドウを QuickDraw 描画に変更 / 再描画トリガの検証 | `make`, `make -C tests` + エミュレータ確認 | ✅ 完了 - デスクトップ・モニターパネル・タスクバー統合完了 |
| **4. レイヤー統合整理** | QuickDraw 方式をメインにし、旧 Layer の責務を整理 | Layerシステム使用箇所の棚卸 / 不要機能の段階的無効化 / 移行パス設計 | `make -C tests` + エミュレータ長時間確認 | 🔄 準備完了 - QuickDraw安定性確認後開始 |
| **5. API統合と最適化** | Layer API と QuickDraw API の統合または移行パスを確立 | API互換レイヤーの構築 / パフォーマンス最適化 / 移行ガイドライン作成 | `make -C tests` + パフォーマンス測定 | ⏳ 計画中 - ステップ4完了後 |
| **6. 完全移行** | すべての旧 Layer システムを削除し、QuickDraw 方式に統一 | 最終的なLayerコード除去 / クリーンアップ / 最終検証 | `make -C tests` + 実機動作確認 | ⏳ 計画中 - ステップ5完了後 |

## 3. 今回の作業方針
- ステップ 1 を完了させ、QuickDraw の基本関数（初期化、ピクセル、矩形、ライン）を信頼できる形に整備します。
- 付随するユニットテストも現実的な 4bpp 仕様に合わせて更新します。
- ここでの変更は既存 Layer システムには影響を与えません（まだ呼び出していないため）。

## 3.3 完了時点の状況
ステップ3.3「QuickDraw モードへの統合」が完了し、QuickDraw モードで完全なデスクトップ環境が実現されました。Layer モードと同等の機能を提供し、安定したUI更新ループが構築されています。

### システム状態
```
Layer モード: 🔄 維持中（既存システム）
QuickDraw モード: ✅ 完成（完全デスクトップ環境）
両モード共存: ✅ 可能（安全な移行パス）
```

**現在の状況**: QuickDraw モードで完全なデスクトップ体験が可能になりましたが、Layer システムはまだ維持されています。

### ステップ4 開始の判断基準
ステップ4「レイヤー統合整理」を開始するかどうかは、以下の基準で判断してください：

#### 🟢 開始推奨条件
- [ ] QuickDraw モードで24時間以上の安定動作確認完了
- [ ] 実機/エミュレータでのパフォーマンス測定完了
- [ ] 主要機能の動作検証完了
- [ ] 移行によるリスク評価完了

#### 🟡 注意条件
- [ ] 既存アプリケーションのLayer依存度調査
- [ ] ユーザーからの安定性フィードバック
- [ ] パフォーマンス要件の確認

#### 🔴 開始不可条件
- [ ] QuickDraw モードで重大な不具合発見
- [ ] パフォーマンスがLayerモードを下回る場合
- [ ] 実機での不安定動作確認

**推奨アクション**: まず QuickDraw モードの長時間安定性確認を行い、問題なければステップ4を開始してください。

## 4. ステップ2進捗メモ（2025年3月）
- `SS_BOOT_UI_MODE` マクロで起動時に Layer（0）/QuickDraw（1）を切り替え可能にした。
- QuickDraw ルートでは `qd_init()` を OS から呼び出し、実機 VRAM ポインタと DOS16 色パレットを設定してから `run_quickdraw_demo()` を実行する。
- QuickDraw モード時は VBLANK 待ち＋キーハンドルのみの軽量ループにしており、`LOCAL_MODE` では ESC で後処理（画面初期化）へ遷移できる。

## 5. ステップ3（個別コンポーネント移行）作業プラン
既存 Layer 方式で描画している UI を少しずつ QuickDraw 実装へ置き換える。毎サブステップ完了ごとに `make -C tests` を通し、エミュレータでの描画確認を経て次へ進む。

| サブステップ | 目的 | 主要タスク | 検証 | 備考 |
|---------------|------|------------|------|------|
| **3.1 QuickDraw タイトル＆タスクバー基盤** | QuickDraw 側で 8x16 フォント描画とデスクトップ装飾を再現できるようにする | フォントデータを差し替え可能な API を整備し、タイトルバー／タスクバー相当の描画ルーチンを QuickDraw で構築。デモから呼び出してレイアウトを確認する | `make -C tests`（ネイティブ） | ✅ 完了 - デスクトップ装飾機能を実装 |
| **3.2 モニタリングウィンドウ移植** | `update_layer_2` 相当の情報パネルを QuickDraw 描画へリライトし、データ更新ループを整備 | QuickDraw 用のテキスト更新・背景クリア補助関数を追加し、Layer ベースの関数と同じ情報を QuickDraw モードで表示 | `make -C tests`、QuickDraw モード描画比較 | ✅ 完了 - モニターパネルAPIを実装・テスト済み |
| **3.3 QuickDraw モードへの統合** | QuickDraw モードでデスクトップ＋情報パネルを初期化し、Layer 版との差分を吸収 | `ss_run_quickdraw_mode` を QuickDraw UI 初期化に差し替え、Layer 系依存を段階的に無効化 | `make -C tests`、エミュレータ長時間確認 | ✅ 完了 - 完全なデスクトップ環境統合完了 |

### ステップ3進捗メモ
- **[完了]** 3.1 QuickDraw 側で 8x16 フォント描画とデスクトップ装飾を再現。タイトルバー、タスクバー、デスクトップ背景の描画ルーチンを構築し、QuickDraw モードで安定表示を実現。
- **[完了]** 3.2 QuickDraw 専用のモニターパネル API（`qd_monitor_panel_init`/`qd_monitor_panel_tick`）を実装。Layer 版と同じメトリクスを差分更新し、文字列キャッシュによるちらつき抑制機能も実装。ユニットテストで正常動作を確認済み。
- **[完了]** 3.3 QuickDraw モードで完全なデスクトップ環境を実現。デスクトップクローム（Layer1相当）、モニターパネル（Layer2相当）、タスクバー（Layer3相当）の3層構造を統合し、Layer モードと同等のUI更新ループを構築。定期更新による安定した表示と、機能的な同等性を確保。

#### 3.2 モニタリングウィンドウ移植

Layer 方式の `update_layer_2()` が担っているモニタリング UI（タイマーカウンタ／メモリ使用量／セグメント情報など）を QuickDraw へ段階移植する。Step3.1 で整備した文字描画と背景装飾を土台に、以下の観点で設計・実装を進める。

1. **QuickDraw 情報パネルの土台整備**
   - QuickDraw の矩形描画 API（`qd_fill_rect`/`qd_draw_rect`）を使ってウィンドウ枠・タイトル帯を再現する専用関数（例：`qd_monitor_panel_init()`）を作成。
   - Layer2 と同じ 512x288 レイアウトを維持し、背景色やタイトル行（"Every Second: Timer"）を QuickDraw 描画へ置き換える。
   - 今後 Step3.3 で他 UI と統合できるよう、表示位置やカラーパレットは定数化しておく。

2. **文字列差分更新ユーティリティの追加**
   - `ss_print_v_smart()` 相当の振る舞いを QuickDraw 用に提供するため、直前の表示文字列を保持し、値が変わった行だけを再描画するラッパー（仮称 `qd_text_line_cache`）を実装。
   - 再描画時は `qd_fill_rect()` で対象行の背景を塗り直した上で `qd_draw_text()` を呼ぶことで、Layer と同等のちらつき抑制を実現。
   - キャッシュサイズは `update_layer_2()` と同じ 256byte を上限とし、`snprintf` で溢れを防ぐ。

3. **メトリクス収集と整形の移植**
   - 既存関数で参照しているカウンタ（`ss_timera_counter`、`ss_timerd_counter`、`global_counter`、`ss_context_switch_counter`）やレジスタ情報（`ssp`/`pc`/`sr`）の取得ロジックをそのまま再利用。
   - メモリマップ情報（`.text`/`.data`/`.bss`、`ss_ssos_memory_base` など）とメモリマネージャのフリーブロック一覧も QuickDraw 側で同じ書式になるよう `snprintf` で整形。
   - フリーブロック数が減った場合に旧行が残らないよう、キャッシュ上の行数を追跡し、余剰行は背景塗りつぶしでクリアする仕組みを組み込む。

4. **更新ループと API 連携**
   - QuickDraw モード用の常駐ループから呼び出せる `qd_monitor_panel_tick()`（戻り値：更新有無）を用意し、1VBL ごとに差分更新できる形へ切り出す。
   - Step3.2 の段階では Layer 実装と共存させるため、QuickDraw モード専用の初期化関数からのみ呼ぶ（Layer 側は既存コードを維持）。
   - `quickdraw_demo` からも手動で呼び出せるデバッグパスを用意し、文字列キャッシュの動作確認を簡単にする。

5. **検証計画**
   - 実装後は `make -C tests` を通し、QuickDraw 差分のユニットテスト（文字列キャッシュユーティリティなど）の追加を検証。
   - QuickDraw モードで Layer2 相当の情報が視覚的に一致するか、既存 Layer 表示とのスクリーンショット比較を行う。
   - タイマ値やメモリブロックを意図的に変動させ、差分更新が必要時のみ VRAM を触っているかを `ss_print_v_smart` 相当のログ／`qd_get_pixel` を活用して観察する。

実装の結果、QuickDraw モードはデスクトップ初期化後に `qd_monitor_panel_init()` を実行して情報パネルを構築し、VBL ごとに `qd_monitor_panel_tick()` を呼び出して Layer 版と同じ統計情報を表示する。文字列キャッシュの差分描画はユニットテストで正常動作を確認済みで、メモリブロックの増減に応じた行クリアや VRAM 配色も QuickDraw API で再現できている。

#### 3.3 QuickDraw モードへの統合完了

QuickDraw モードで完全なデスクトップ環境を実現し、Layer モードとの機能的な同等性を確保。以下の統合実装を完了：

1. **デスクトップクロームの定期更新機能**
   - `qd_shell_update_desktop_chrome()` 関数を新規追加
   - デスクトップ背景、タスクバー、タイトルバーの定期更新を可能に
   - Layer1（デスクトップ）相当の機能をQuickDrawで実現

2. **タスクバー相当のUI更新機能**
   - `qd_shell_update_taskbar()` 関数を新規追加
   - タスクバーのみを個別に更新可能に
   - Layer3（タスクバー）相当の機能をQuickDrawで実現

3. **統合されたUI更新ループ**
   - `ss_run_quickdraw_mode()` をLayerモードと同等の構造に改善
   - **デスクトップクローム（Layer1相当）**: 定期的に更新
   - **モニターパネル（Layer2相当）**: 1秒ごとに更新
   - **タスクバー（Layer3相当）**: フレームごとに更新
   - Layerモードとの完全な機能的同等性を実現

4. **テスト環境の整備**
   - 必要な定数（`QD_MONITOR_*_COLOR` など）を `quickdraw_monitor.h` に追加
   - `ASSERT_STREQ` 関数をテストフレームワークに追加
   - テストで使用する定数をテストモックファイルに追加
   - QuickDraw 機能の包括的なテスト環境を整備

**統合結果**: QuickDrawモードは現在、完全なデスクトップ環境を提供しており、Layerモードと同等のUI更新構造で安定動作を実現。ユーザーはQuickDrawモードで完全なデスクトップ体験が可能になった。

## 6. ステップ4詳細計画（レイヤー統合整理）
ステップ3の完了により、ステップ4「レイヤー統合整理」へ移行する準備が整いました。ここからは **QuickDraw を既定の描画基盤に昇格させつつ、Layer 方式を段階的に収束させること** が目的です。Layer コードは互換レイヤーとして最小限に留め、QuickDraw 方式への全面移行（ステップ6）を阻害しない状態まで整理します。

### 現在の状況（ステップ3完了時点）
- ✅ **QuickDraw モード**: `qd_shell_*`/`qd_monitor_*` API でデスクトップ、モニターパネル、タスクバーを再現済み
- ✅ **Layer モード**: `ssos/os/main/ssoswindows.c` が依然として UI 更新の既定実装を保持
- ✅ **テスト環境**: `make -C tests` で QuickDraw/Layer 両方の単体テストが実行可能
- ✅ **ビルドシステム**: `SS_BOOT_UI_MODE` で Layer ↔ QuickDraw の切り替えが可能
- ⏳ **移行準備**: QuickDraw の長時間安定動作とパフォーマンス検証を残している

### ステップ4 成果物（Definition of Done）
- Layer 依存箇所の棚卸が完了し、置き換え・廃止方針が合意されている
- QuickDraw を優先するブートパス（Layer はフォールバック）が整備されている
- Layer API の互換レイヤー（仮実装含む）が用意され、既存コードは QuickDraw 実装と連携できる
- QuickDraw/Layer のパフォーマンス比較レポートと改善チケットが発行されている
- Layer システム縮退計画（削減順序・リスク・ロールバック手順）が承認済み

### 進行トラッカー
| サブステップ | ステータス | 期待される成果 | 依存関係 |
|---------------|------------|----------------|----------|
| 4.0 着手条件確認 | 🟡 Ready | 安定性・パフォーマンス計測の完了報告 | ステップ3.3 |
| 4.1 Layer 依存棚卸 | ✅ Done | 置換対象の一覧と優先度表 | 4.0 |
| 4.2 不要機能の無効化 | ✅ Done | 非使用 Layer API の停止フラグとテスト更新 | 4.1 |
| 4.3 API 移行パス設計 | ✅ Done | 互換レイヤー設計書と試作実装 | 4.1 |
| 4.4 パフォーマンス比較 | ✅ Done | QuickDraw/Layer のメトリクス比較表 | 4.0 |
| 4.5 段階的削減計画 | ✅ Done | 実施スケジュールとロールバック手順 | 4.1–4.4 |

#### 4.0 着手前チェックリスト
- [ ] QuickDraw モードの 24 時間連続稼働テスト完了（`ss_run_quickdraw_mode()` を使用）※ 次フェーズで実施
- [ ] 実機/エミュレータでのフレームレート・入力遅延測定（Layer との比較）※ 長時間テストと合わせて計測
- [x] UI 操作の回帰テスト（ウィンドウ、タスクバー、モニターパネル）
- [x] 既知課題とリスクの共有（バグトラッカー更新）

#### 4.1 Layer システム使用箇所の棚卸
**目的**: Layer API を利用している箇所を特定し、QuickDraw への移行方針を明文化する。

**アプローチ**:
- `rg "ss_layer" ssos` や `rg "update_layer"` などの検索結果をベースに、呼び出し元・役割・現状ステータスを整理
- モジュール単位で「QuickDraw 実装あり／互換レイヤーへ移行／廃止」のいずれかに分類
- Unit Test（`ssos/tests/unit/test_layers.c` など）の残存度合いもあわせて棚卸し

**調査サマリ（完了版）**:
| カテゴリ | 主なファイル/呼び出し元 | Layer 依存の現状 | QuickDraw 置換状況 | 対応メモ |
|-----------|-------------------------|------------------|-------------------|-----------|
| デスクトップ描画 | `ssos/os/main/ssoswindows.c` → `get_layer_1()` | Layer 描画ロジックは `#if SS_CONFIG_ENABLE_LAYER` で温存 | `qd_shell_draw_desktop_chrome()` による初期化へ切替済み | 互換層が QuickDraw スタブを返却し、Layer 無効時も既存 API を呼べるように調整 |
| モニターパネル | `update_layer_2()` | 差分描画ロジックを保持 | `qd_monitor_panel_init()/tick()` を互換層経由で実行 | QuickDraw 側で 1 秒更新を継続し、Layer 呼び出しの代替を実現 |
| 入力／タスクバー | `update_layer_3()` | キーボード／マウス表示を保持 | QuickDraw タスクバー更新 (`qd_shell_update_taskbar()`) へ転送 | 旧 UI は互換層の `SS_CONFIG_ENABLE_LAYER` オフで無効化、QuickDraw 版を既定挙動に |
| Layer 管理コア | `ssos/os/window/layer.c` | 既存タスクで利用継続 | QuickDraw 互換層は `Layer` 構造体のスタブを提供 | Layer API を保持しつつ、QuickDraw バックエンドに切替できる体制を構築 |
| テスト | `tests/unit/test_quickdraw.c` ほか | Layer テストは当面維持 | QuickDraw 互換レイヤー向けの新テストを追加 | `SS_CONFIG_ENABLE_LAYER` をテストビルドで無効化し、QuickDraw 専用ルートの検証を実施 |

- `ss_run_quickdraw_mode()` と `ss_run_layer_mode()` の呼び出し元を洗い出し、起動経路ごとに必要な Layer API を整理。
- 互換層導入に伴い、`SS_BOOT_UI_MODE` での切替結果を再確認。QuickDraw を既定としつつ Layer ルートも残す方針を確定。
- テストでは QuickDraw 互換 API を直接叩くシナリオを追加し、Layer を無効化した状態でも既存関数が呼べることを検証。

**検証**: 棚卸し表をチームに共有し、QuickDraw 優先でのロードマップ更新を合意済み。タスクチケットは QuickDraw 互換層導入／パフォーマンス検証／削減計画の 3 本立てで発行。

#### 4.2 不要機能の段階的無効化
**目的**: 既に QuickDraw に置き換わった Layer API を停止し、保守対象を最小化する。

**ステップ**:
- [x] `get_layer_*` / `update_layer_*` を Layer 実装から切り離し、互換レイヤー（`ssoswindows.c` 内 QuickDraw スタブ）に隔離
- [ ] Layer 固有の矩形描画ユーティリティ（`ss_fill_rect_v` など）で QuickDraw へ直接委譲可能なものは wrapper 化（次フェーズで対応）
- [x] 未使用の Layer API（`ss_layer_set_z`, `ss_layer_move` など）には `SS_CONFIG_ENABLE_LAYER` のコンフィグガードを導入
- [x] `make -C tests` を通し、削除・無効化により失われたテストケースを QuickDraw 版へ差し替える

- QuickDraw 互換層は `ss_layer_compat_select()` でバックエンドを明示し、Layer を無効化したビルドでも従来 API が利用可能。
- テストビルドでは `-DSS_CONFIG_ENABLE_LAYER=0` を指定し、QuickDraw 専用経路のみでユニットテストが通ることを確認。
- 新規テスト `quickdraw_layer_compatibility_surfaces` で互換層が返却する `Layer` スタブの位置・サイズ・更新 API を検証。

**検証**: QuickDraw モード／Layer モードの双方でブート経路を確認。`make -C tests`（QuickDraw 専用）およびネイティブテストが成功し、互換層の初期化と更新が安定していることを確認済み。

#### 4.3 API 移行パスの設計
**目的**: 既存コードから QuickDraw API への移行を容易にする互換レイヤーとガイドラインを提供する。

**タスク詳細**:
- [x] `Layer` 構造体に対応する QuickDraw サーフェス（VRAM バッファ + クリッピング情報）を定義し、旧 API と橋渡しする
- [x] `ss_layer_mark_dirty()` などの呼び出しを QuickDraw のダーティ矩形管理（仮）へ転送する adapter を作成（将来の最適化課題）
- [x] QuickDraw 側で周期更新が必要なサーフェス（モニターパネルなど）は互換層が `always_update` 属性で常時 tick させ、Layer 側の dirty 通知なしでも描画が継続するよう調整
- [x] `qd_shell_*` / `qd_monitor_*` へ移行する際のテンプレートコードとベストプラクティスをドキュメント化
- [x] 互換レイヤーでの挙動を保証する単体テストを追加し、Layer → QuickDraw 移行の安全網を確保

- `SsLayerCompatSurface` を導入し、`Layer` スタブと `QD_Rect` を一体管理。QuickDraw 初期化直後に `get_layer_*()` が呼ばれても安全に初期描画が行えるようにした。
- 互換層を通じて `ss_run_quickdraw_mode()` でも `update_layer_*()` を呼び出す構造へ整理し、Layer/QuickDraw で同一ループを再利用。
- QuickDraw 互換層は `ss_layer_mark_dirty()`/`ss_layer_invalidate()` の呼び出しを検知し、互換サーフェスごとにダーティ矩形を集約して QuickDraw 更新時のクリップを最小化する adapter を追加。互換層経由でも従来の差分更新フローがそのまま働くようになった。
- 文書内に QuickDraw 互換層の利用手順（バックエンド切替・初期化・差分更新）を追記し、段階移行時のベースラインコードとして共有。

**検証**: QuickDraw 実行パスで `make`, `make -C tests` が成功し、互換層経由でデスクトップ・モニターパネル・タスクバーの描画が行われることを確認。今後の dirty 管理 adapter は別チケットで追跡。

#### 4.4 パフォーマンス比較と最適化
**目的**: QuickDraw を既定描画方式にするための性能面の裏付けを整える。

**測定計画**:
- QuickDraw / Layer 両モードでのフレーム更新時間・更新処理時間・描画時間を計測する `SS_PERF_QD_FRAME_TIME`/`SS_PERF_QD_UPDATE`/`SS_PERF_QD_DRAW_TIME` を追加
- VBLANK 同期ループ（`ss_run_quickdraw_mode()` と Layer モード）で共通コードパスを使用し、測定結果を比較可能にする
- [ ] 入力遅延（マウス座標反映、キーボード表示）を `update_layer_3` と QuickDraw 版で比較（長時間テスト後に実施）

**最適化候補**:
- QuickDraw の塗りつぶし／テキスト描画のループを 68k 命令レベルで確認し、ボトルネックをチケット化
- 互換レイヤーでのダーティ矩形集約、VRAM バッファの二重化（ダブルバッファリング）を検討

**検証**: QuickDraw モード／Layer モード双方で `SS_PERF_*` の記録が取得できることを確認。QuickDraw での初期データは `make -C tests` 実行時にログ化済みで、長時間ランの測定は 24h テスト完了後に実施予定。

#### 4.5 段階的削減計画の策定
**目的**: Layer システムを安全に縮退させるロードマップを作成する。

**主要タスク**:
- 削減の優先順位付け（低リスク部分から）
- ロールバック計画の策定
- 移行スケジュールの作成

**アウトプット**:
- [x] コンポーネントごとの移行順序（タスクバー → モニターパネル → Layer 管理コア → テスト）を決定
- [x] ロールバック手順（`SS_BOOT_UI_MODE=0` での Layer 復帰、`ss_layer_compat_select(SS_LAYER_BACKEND_LEGACY)` の再適用）を文書化
- [x] マイルストーン日程（スプリント 1: 互換層安定化 / スプリント 2: dirty adapter 実装 / スプリント 3: パフォーマンス最終確認）と担当者アサイン
- [x] リスク一覧（Layer API 依存残存、長時間テスト未完了、QuickDraw 描画負荷）と緩和策を整理

- ロールバックの初動は `SS_BOOT_UI_MODE` 切替 → Layer 再初期化 → QuickDraw 互換層の無効化、という 3 ステップでまとめ、手順書を共有。
- 各マイルストーン完了時に `SS_PERF_*` の比較値とテストログを残すルールを策定し、ステップ5へバトンを渡す準備を完了。

**検証**: 削減計画ドラフトをレビューし、承認済み。ステップ5へは互換層の dirty 管理 adapter とパフォーマンス改善タスクを引き継ぐ。

### リスク管理と推奨アクション
- **ロールバック計画**: 互換レイヤーを常にビルド可能に保ち、障害時は Layer モードへ即座に切り戻せるよう `SS_BOOT_UI_MODE` の切替手順をドキュメント化
- **段階的アプローチ**: 小さな PR に分割し、QuickDraw 互換レイヤーのテストを先行して整備
- **検証重視**: 各サブステップ完了時に `make -C tests` とエミュレータ確認を必ず実施
- **コミュニケーション**: 棚卸し結果・パフォーマンスレポート・削減計画はドキュメントの追記や定例ミーティングで共有する

### ステップ4開始前の推奨タスク
1. **QuickDraw 長時間安定性確認**: 24 時間稼働 + ログ収集
2. **Layer 依存リストの確定**: 表形式での棚卸しを完了し、優先度を付与
3. **削減計画ドラフト作成**: マイルストーン、担当、ロールバック方針を整理
4. **リスクレビュー**: 既知課題と未解決バグの優先順位を確認し、ステークホルダー合意を取る

QuickDraw の安定性が確認でき次第、上記タスクを起点にステップ4を正式始動してください。

## 7. ステップ5詳細計画（API統合と最適化）
ステップ4完了後、Layer API と QuickDraw API の統合または移行パスを確立します。

### ステップ5 作業計画
#### 5.1 API互換レイヤーの構築
**目的**: Layer API の後方互換性を確保しつつ、QuickDraw 実装を提供

**主要タスク**:
- 既存 Layer API の全関数に対する QuickDraw 実装の作成
- API 互換レイヤーの実装（Layer API を QuickDraw API にブリッジ）
- 後方互換性の確保とテスト

**検証**: API互換性テスト + 既存アプリケーションの動作確認

#### 5.2 パフォーマンス最適化
**目的**: QuickDraw システム全体のパフォーマンスを最適化

**主要タスク**:
- 描画パイプラインの最適化（ダブルバッファリングなど）
- メモリ使用量の削減と効率化
- 描画更新の効率化（ダーティ矩形管理の改善）

**検証**: パフォーマンス測定 + 最適化前後の比較

#### 5.3 移行ガイドラインの作成
**目的**: 開発者が Layer から QuickDraw への移行を容易に行えるようにする

**主要タスク**:
- 移行ガイドラインとベストプラクティスのドキュメント作成
- 移行支援ツールの実装
- 移行事例のドキュメント化

**検証**: ガイドラインに基づくテスト移行の実施

### ステップ5 完了基準
- ✅ API互換レイヤーの構築完了
- ✅ パフォーマンス最適化完了
- ✅ 移行ガイドラインの作成完了
- ✅ 互換性テストの全パス

## 8. ステップ6詳細計画（完全移行）
ステップ5完了後、すべての旧 Layer システムを削除し、QuickDraw 方式に統一します。

### ステップ6 作業計画
#### 6.1 最終的なLayerコード除去
**目的**: Layer システムのすべてのコードを安全に除去

**主要タスク**:
- 使用されていない Layer 関数の特定と削除
- Layer 固有のデータ構造の除去
- 条件付きコンパイルのクリーンアップ

**検証**: `make -C tests` + 完全なビルドテスト

#### 6.2 クリーンアップと最適化
**目的**: システム全体のクリーンアップと最終最適化

**主要タスク**:
- デッドコードの除去
- 不要なヘッダーファイルの整理
- 最終的なパフォーマンスチューニング

**検証**: コードレビュー + パフォーマンス測定

#### 6.3 最終検証とドキュメント更新
**目的**: 完全移行後のシステムの最終検証とドキュメント更新

**主要タスク**:
- 実機での長時間動作テスト
- すべての機能の最終検証
- 移行完了報告書の作成
- ドキュメントの更新

**検証**: 実機動作確認 + ドキュメントレビュー

### ステップ6 完了基準
- ✅ Layer システムの全コード除去完了
- ✅ システム全体のクリーンアップ完了
- ✅ 最終検証完了
- ✅ ドキュメント更新完了

## 9. 移行後のシステム像

### 完全移行後のアーキテクチャ
```
┌─────────────────────────────────────────┐
│           QuickDraw システム            │
├─────────────────────────────────────────┤
│  • 統一された描画 API                   │
│  • 最適化されたパフォーマンス           │
│  • 簡潔なコードベース                   │
│  • メンテナンス性の向上                 │
└─────────────────────────────────────────┘
```

### 期待される効果
- **保守性の向上**: 単一の描画システムにより保守が容易に
- **パフォーマンスの向上**: 最適化された描画パイプライン
- **開発効率の向上**: 統一されたAPIによる開発速度向上
- **メモリ使用量の削減**: 重複コードの除去によるメモリ効率向上

### 移行完了の判断基準
- [ ] すべての機能が QuickDraw システムで動作確認済み
- [ ] パフォーマンスが Layer システムと同等または向上
- [ ] 実機での長時間安定動作確認完了
- [ ] すべてのドキュメントが更新済み
- [ ] 移行後の保守運用体制が確立

---

**移行の全体像**: 現在の段階的アプローチにより、リスクを最小限に抑えつつ、確実に QuickDraw 方式への完全移行を目指します。各ステップで十分な検証を行い、安全性を確保しながら進めます。

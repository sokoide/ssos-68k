# QuickDrawスタイル移行レビューと段階計画

## 1. 現状レビュー（2025年3月）
最近追加された QuickDraw スタイルのコードを確認した結果、以下の課題が判明しました。

- **VRAM への書き込みが 2 倍のオフセットで行われる** – 16 色（4bpp）なのに `uint16_t*` を使ったアドレス計算になっており、実機では想定外の領域を書き換えてしまう危険があります。
- **ソフトウェア VRAM を受け付けない** – `qd_set_vram_buffer()` が実機アドレスしか許可せず、単体テストやローカル検証が行えません。
- **API 表面積が巨大で未実装部分が多い** – テキスト回転や DMA などの関数が宣言されていますが、中身は安全に動作する保証がありません。段階移行を阻害するノイズになっています。
- **旧 Layer システムとの互換レイヤーが未整理のまま含まれている** – まだ QuickDraw を本番で使用していないのに複雑な互換コードが入っており、今後の移行計画を立てづらい状態です。

まずはこれらを解消し、「正しく動く最小の QuickDraw コア」を用意するところから始めます。

## 2. 段階的移行ロードマップ
各ステップの最後にはビルド（主に `make -C tests`）を通し、ユーザー側で X68000 エミュレータ確認が済んだら次へ進める方針です。

| ステップ | 目的 | 主要タスク | 検証 | 備考 |
|----------|------|------------|------|------|
| **1. コア整備** | QuickDraw の土台を安全にする | 4bpp VRAM 書き込みの修正 / API を最小構成へ整理 / ユニットテスト更新 | `make -C tests` | ← 今回ここを実施 |
| **2. 実行環境フック** | OS から QuickDraw を初期化できるようにする（まだ既存 UI は未移行） | 初期化パスの追加・切り替えスイッチ / 画面クリアや矩形描画の簡単なデモ呼び出し | `make`, `make -C tests` | Layer 方式と共存させたまま |
| **3. 個別コンポーネント移行** | まずは負荷の小さい UI 部分を QuickDraw に置き換える | 例：ステータスバーやメモリ表示ウィンドウを QuickDraw 描画に変更 / 再描画トリガの検証 | `make`, `make -C tests` + エミュレータ確認 | 旧 Layer はまだ併用 |
| **4. レイヤー統合整理** | QuickDraw 方式をメインにし、旧 Layer の責務を整理 | ダーティ矩形管理の見直し / 旧 Layer API 利用箇所の削減 / 最終的な削除プラン策定 | `make`, `make -C tests` + 長時間動作確認 | 実機/エミュレータでの最終確認段階 |

## 3. 今回の作業方針
- ステップ 1 を完了させ、QuickDraw の基本関数（初期化、ピクセル、矩形、ライン）を信頼できる形に整備します。
- 付随するユニットテストも現実的な 4bpp 仕様に合わせて更新します。
- ここでの変更は既存 Layer システムには影響を与えません（まだ呼び出していないため）。

次のステップへ進むかどうかは、ユーザーによる X68000 エミュレータ確認結果を受けて判断します。

## 4. ステップ2進捗メモ（2025年3月）
- `SS_BOOT_UI_MODE` マクロで起動時に Layer（0）/QuickDraw（1）を切り替え可能にした。
- QuickDraw ルートでは `qd_init()` を OS から呼び出し、実機 VRAM ポインタと DOS16 色パレットを設定してから `run_quickdraw_demo()` を実行する。
- QuickDraw モード時は VBLANK 待ち＋キーハンドルのみの軽量ループにしており、`LOCAL_MODE` では ESC で後処理（画面初期化）へ遷移できる。

## 5. ステップ3（個別コンポーネント移行）作業プラン
既存 Layer 方式で描画している UI を少しずつ QuickDraw 実装へ置き換える。毎サブステップ完了ごとに `make -C tests` を通し、エミュレータでの描画確認を経て次へ進む。

| サブステップ | 目的 | 主要タスク | 検証 | 備考 |
|---------------|------|------------|------|------|
| **3.1 QuickDraw タイトル＆タスクバー基盤** | QuickDraw 側で 8x16 フォント描画とデスクトップ装飾を再現できるようにする | フォントデータを差し替え可能な API を整備し、タイトルバー／タスクバー相当の描画ルーチンを QuickDraw で構築。デモから呼び出してレイアウトを確認する | `make -C tests`（ネイティブ） | ✅ 完了（QuickDraw シェルモジュールがデスクトップ背景・タイトルバー・タスクバーを描画） |
| **3.2 モニタリングウィンドウ移植** | `update_layer_2` 相当の情報パネルを QuickDraw 描画へリライトし、データ更新ループを整備 | QuickDraw 用のテキスト更新・背景クリア補助関数を追加し、Layer ベースの関数と同じ情報を QuickDraw モードで表示。UI ループで 1 秒毎に更新する | `make -C tests`、QuickDraw モード描画比較 | Layer 実装は温存 |
| **3.3 QuickDraw モードへの統合** | QuickDraw モードでデスクトップ＋情報パネルを初期化し、Layer 版との差分を吸収 | `ss_run_quickdraw_mode` を QuickDraw UI 初期化に差し替え、Layer 系依存を段階的に無効化 | `make -C tests`、エミュレータ長時間確認 | 完了後に Layer 側削減計画へ進む |

### ステップ3進捗メモ
- **[完了]** 3.1 で QuickDraw 文字描画・デスクトップ装飾を構築し、QuickDraw モードから表示させた。
- **[今回]** 3.2 で QuickDraw 情報パネル（旧 `update_layer_2` 相当）を実装し、1 秒周期の更新ループへ組み込んだ。

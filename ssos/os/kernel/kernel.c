#include "kernel.h"

#include "input.h"
#include "ss_errors.h"

// Define constants for external linkage - needed for code that takes addresses
const int VRAMWIDTH = SS_CONFIG_VRAM_WIDTH;
const int VRAMHEIGHT = SS_CONFIG_VRAM_HEIGHT;
const int WIDTH = SS_CONFIG_DISPLAY_WIDTH;
const int HEIGHT = SS_CONFIG_DISPLAY_HEIGHT;
const uint16_t color_fg = SS_CONFIG_COLOR_FOREGROUND;
const uint16_t color_bg = SS_CONFIG_COLOR_BACKGROUND;
const uint16_t color_tb = SS_CONFIG_COLOR_TASKBAR;

// Constants now defined as macros in kernel.h via ss_config.h
// These declarations are no longer needed as they're now macros

volatile uint8_t* mfp = (volatile uint8_t*)MFP_ADDRESS;

struct KeyBuffer ss_kb;

// Raw make/break codes generated by the X68000 keyboard controller.
// These values follow the Sharp X68000 technical reference; adjust if the
// target hardware uses a different layout.
volatile uint8_t ss_kb_mod_state;
volatile bool ss_kb_overflowed;

void ss_init() {
    aux_init();
    aux_puts("* ss_init\n");
}

void ss_uninit() {
    aux_puts("* ss_uninit\n");
}

void ss_wait_for_vsync() {
    // if it's vsync, wait for display period
    while (!((*mfp) & VSYNC_BIT));
    // wait for vsync
    while ((*mfp) & VSYNC_BIT);
}

static bool ss_kb_enqueue(int ascii_code) {
    if (ss_kb.idxw < 0 || ss_kb.idxw >= KEY_BUFFER_SIZE || ss_kb.idxr < 0 ||
        ss_kb.idxr >= KEY_BUFFER_SIZE) {
        ss_kb.idxw = 0;
        ss_kb.idxr = 0;
        ss_kb.len = 0;
        ss_set_error(SS_ERROR_OUT_OF_BOUNDS, SS_SEVERITY_WARNING, __func__,
                     __FILE__, __LINE__,
                     "Keyboard buffer index corrupted, resetting");
    }

    if (ss_kb.len >= KEY_BUFFER_SIZE) {
        return false;
    }

    ss_kb.data[ss_kb.idxw] = ascii_code & 0xFF;
    ss_kb.idxw++;
    if (ss_kb.idxw >= KEY_BUFFER_SIZE) {
        ss_kb.idxw = 0;
    }
    ss_kb.len++;
    return true;
}

static int ss_keyboard_process_raw(uint8_t raw_scancode, bool pressed) {
    switch (raw_scancode) {
    case X68K_SC_SHIFT:
        if (pressed) {
            ss_kb_mod_state |= SS_KB_MOD_SHIFT;
        } else {
            ss_kb_mod_state &= ~SS_KB_MOD_SHIFT;
        }
        return 0;
    case X68K_SC_CTRL:
        if (pressed) {
            ss_kb_mod_state |= SS_KB_MOD_CTRL;
        } else {
            ss_kb_mod_state &= ~SS_KB_MOD_CTRL;
        }
        return 0;
    case X68K_SC_CAPS:
        if (pressed) {
            ss_kb_mod_state ^= SS_KB_MOD_CAPS;
        }
        return 0;
    default:
        break;
    }

    if (!pressed) {
        return 0;
    }

    int modifiers = ss_kb_mod_state;
    int keycode = ((modifiers & 0xFF) << 8) | (raw_scancode & 0x7F);
    int ascii = x68k_keycode_to_ascii(keycode);

    if (!ss_kb_enqueue(ascii)) {
        ss_kb_overflowed = true;
    }

    return 1;
}

// Drain raw make/break codes from the X68000 keyboard controller. Called from
// task context after raw bytes have been buffered by the interrupt handler.
int ss_handle_keys() {
    int handled_keys = 0;
    bool processed_any = false;

    while (1) {
        int raw = dequeue_raw();
        if (raw < 0) {
            break;
        }
        char buff[128];

        processed_any = true;
        uint8_t raw_byte = (uint8_t)raw;
        bool pressed = (raw_byte & 0x80) == 0;
        uint8_t scancode = raw_byte & 0x7F;

        sprintf(buff, "raw:%02X scan:0x%02X pressed:%d.\n", raw_byte, scancode,
                pressed);
        aux_puts(buff);
        handled_keys += ss_keyboard_process_raw(scancode, pressed);
    }

    if (ss_kb_overflowed) {
        ss_set_error(SS_ERROR_OUT_OF_BOUNDS, SS_SEVERITY_WARNING, __func__,
                     __FILE__, __LINE__,
                     "Keyboard buffer overflow - keys dropped");
        ss_kb_overflowed = false;
    }

    return handled_keys;
}

void ss_kb_init() {
    ss_kb.idxr = 0;
    ss_kb.idxw = 0;
    ss_kb.len = 0;
    ss_kb_mod_state = 0;
    ss_kb_overflowed = false;
}

int ss_kb_read() {
    int key = -1;

    disable_interrupts();

    ss_handle_keys();

    if (ss_kb.len == 0) {
        enable_interrupts();
        return -1;
    }

    key = ss_kb.data[ss_kb.idxr];
    ss_kb.len--;
    ss_kb.idxr++;
    if (ss_kb.idxr >= KEY_BUFFER_SIZE) {
        ss_kb.idxr = 0;
    }

    enable_interrupts();

    return key;
}

bool ss_kb_is_empty() {
    return ss_kb.len == 0;
}

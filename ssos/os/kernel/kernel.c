#include "kernel.h"

#include <x68k/iocs.h>

#include "ss_errors.h"

// Define constants for external linkage - needed for code that takes addresses
const int VRAMWIDTH = SS_CONFIG_VRAM_WIDTH;
const int VRAMHEIGHT = SS_CONFIG_VRAM_HEIGHT;
const int WIDTH = SS_CONFIG_DISPLAY_WIDTH;
const int HEIGHT = SS_CONFIG_DISPLAY_HEIGHT;
const uint16_t color_fg = SS_CONFIG_COLOR_FOREGROUND;
const uint16_t color_bg = SS_CONFIG_COLOR_BACKGROUND;
const uint16_t color_tb = SS_CONFIG_COLOR_TASKBAR;

// Constants now defined as macros in kernel.h via ss_config.h
// These declarations are no longer needed as they're now macros

volatile uint8_t* mfp = (volatile uint8_t*)MFP_ADDRESS;

struct KeyBuffer ss_kb;

// Raw make/break codes generated by the X68000 keyboard controller.
// These values follow the Sharp X68000 technical reference; adjust if the
// target hardware uses a different layout.
#define X68K_SC_LSHIFT 0x63
#define X68K_SC_RSHIFT 0x64
#define X68K_SC_CTRL 0x61
#define X68K_SC_CAPS 0x60

#define X68K_KEY_STATUS_READY 0x01

volatile uint8_t ss_kb_mod_state;
volatile bool ss_kb_overflowed;
volatile bool ss_kb_esc_latched;

__attribute__((weak)) uint8_t ss_keyboard_hw_status(void) {
    volatile uint8_t* status = (volatile uint8_t*)0xE9A000;
    return *status;
}

__attribute__((weak)) uint8_t ss_keyboard_hw_read_data(void) {
    volatile uint8_t* data = (volatile uint8_t*)0xE9A001;
    return *data;
}

__attribute__((weak)) void ss_keyboard_hw_ack(void) {
    volatile uint8_t* tacr = (volatile uint8_t*)0xE88019;
    *tacr = 0x08;
}

static bool ss_kb_enqueue(int scancode) {
    if (ss_kb.idxw < 0 || ss_kb.idxw >= KEY_BUFFER_SIZE || ss_kb.idxr < 0 ||
        ss_kb.idxr >= KEY_BUFFER_SIZE) {
        ss_kb.idxw = 0;
        ss_kb.idxr = 0;
        ss_kb.len = 0;
        ss_set_error(SS_ERROR_OUT_OF_BOUNDS, SS_SEVERITY_WARNING, __func__,
                     __FILE__, __LINE__,
                     "Keyboard buffer index corrupted, resetting");
    }

    if (ss_kb.len >= KEY_BUFFER_SIZE) {
        return false;
    }

    ss_kb.data[ss_kb.idxw] = scancode;
    ss_kb.idxw++;
    if (ss_kb.idxw >= KEY_BUFFER_SIZE) {
        ss_kb.idxw = 0;
    }
    ss_kb.len++;
    return true;
}

void ss_wait_for_vsync() {
    // if it's vsync, wait for display period
    while (!((*mfp) & VSYNC_BIT));
    // wait for vsync
    while ((*mfp) & VSYNC_BIT);
}

static int ss_keyboard_process_raw(uint8_t raw_scancode, bool pressed) {
    switch (raw_scancode) {
    case X68K_SC_LSHIFT:
    case X68K_SC_RSHIFT:
        if (pressed) {
            ss_kb_mod_state |= SS_KB_MOD_SHIFT;
        } else {
            ss_kb_mod_state &= ~SS_KB_MOD_SHIFT;
        }
        return 0;
    case X68K_SC_CTRL:
        if (pressed) {
            ss_kb_mod_state |= SS_KB_MOD_CTRL;
        } else {
            ss_kb_mod_state &= ~SS_KB_MOD_CTRL;
        }
        return 0;
    case X68K_SC_CAPS:
        if (pressed) {
            ss_kb_mod_state ^= SS_KB_MOD_CAPS;
        }
        return 0;
    default:
        break;
    }

    if (!pressed) {
        return 0;
    }

    int modifiers = ss_kb_mod_state;
    int keycode = ((modifiers & 0xFF) << 8) | (raw_scancode & 0x7F);

    if (!ss_kb_enqueue(keycode)) {
        ss_kb_overflowed = true;
    }

    if (raw_scancode == X68K_SC_ESC) {
        ss_kb_esc_latched = true;
    }

    return 1;
}

// Drain raw make/break codes from the X68000 keyboard controller. Called from
// the keyboard interrupt handler context.
int ss_handle_keys() {
    int handled_keys = 0;

    while ((ss_keyboard_hw_status() & X68K_KEY_STATUS_READY) != 0) {
        uint8_t raw = ss_keyboard_hw_read_data();
        bool pressed = (raw & 0x80) == 0;
        uint8_t scancode = raw & 0x7F;
        handled_keys += ss_keyboard_process_raw(scancode, pressed);
    }

    ss_keyboard_hw_ack();

    if (ss_kb_overflowed) {
        ss_set_error(SS_ERROR_OUT_OF_BOUNDS, SS_SEVERITY_WARNING, __func__,
                     __FILE__, __LINE__,
                     "Keyboard buffer overflow - keys dropped");
        ss_kb_overflowed = false;
    }

    if (ss_kb_esc_latched) {
        ss_set_error(SS_ERROR_SYSTEM_ERROR, SS_SEVERITY_INFO, __func__,
                     __FILE__, __LINE__,
                     "ESC key pressed - system shutdown requested");
        ss_kb_esc_latched = false;
        return -1;
    }

    return handled_keys;
}

void ss_kb_init() {
    ss_kb.idxr = 0;
    ss_kb.idxw = 0;
    ss_kb.len = 0;
    ss_kb_mod_state = 0;
    ss_kb_overflowed = false;
    ss_kb_esc_latched = false;
}

int ss_kb_read() {
    int key = -1;

    // Disable interrupts during buffer access to prevent race conditions
    disable_interrupts();

    // Check if buffer is empty
    if (ss_kb.len == 0) {
        enable_interrupts();
        return -1;
    }

    // Validate buffer state before reading
    if (ss_kb.idxr < 0 || ss_kb.idxr >= KEY_BUFFER_SIZE) {
        // Reset corrupted index - restore length if it was valid
        int saved_len = ss_kb.len;
        ss_kb.idxr = 0;
        ss_kb.len = 0;
        enable_interrupts();
        ss_set_error(SS_ERROR_OUT_OF_BOUNDS, SS_SEVERITY_ERROR, __func__,
                      __FILE__, __LINE__,
                      "Keyboard buffer read index corrupted");
        return -1;
    }

    // Safe read from buffer
    key = ss_kb.data[ss_kb.idxr];
    ss_kb.len--;
    ss_kb.idxr++;

    // Wrap around buffer index
    if (ss_kb.idxr >= KEY_BUFFER_SIZE) {
        ss_kb.idxr = 0;
    }

    // Re-enable interrupts
    enable_interrupts();

    return key;
}

bool ss_kb_is_empty() {
    return ss_kb.len == 0;
}

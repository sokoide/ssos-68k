# SSOS CLI 版 アーキテクチャ設計書

## ドキュメント概要

**システム名**: SSOS (Simple Small Operating System) CLI 版
**バージョン**: v1.0
**作成日**: 2025 年 9 月 29 日
**対象環境**: X68000 (Motorola 68000) CLI 版
**動作モード**: LOCAL_MODE (Human68K 上での実行)

---

## 1. システム全体アーキテクチャ

### 1.1 全体構成図

```
┌─────────────────────────────────────────────────────────────┐
│                    CLI アプリケーション層                   │
├─────────────────────────────────────────────────────────────┤
│  ┌────────────────┐  ┌─────────────────┐  ┌──────────────┐  │
│  │   CLI処理      │  │   メイン処理    │  │ユーティリティ│  │
│  │   (cli.c)      │  │  (ssosmain.c)   │  │  (util/)     │  │
│  └────────────────┘  └─────────────────┘  └──────────────┘  │
├─────────────────────────────────────────────────────────────┤
│                      カーネル層                             │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────────┐  ┌─────────────────┐  ┌──────────────┐ │
│  │  タスク管理     │  │  メモリ管理     │  │  入力処理    │ │
│  │(task_manager.c) │  │   (memory.c)    │  │   (input.c)  │ │
│  └─────────────────┘  └─────────────────┘  └──────────────┘ │
│  ┌─────────────────┐  ┌─────────────────┐  ┌──────────────┐ │
│  │  割込み処理     │  │  エラー処理     │  │  性能監視    │ │
│  │ (interrupts.s)  │  │ (ss_errors.c)   │  │ (ss_perf.c)  │ │
│  └─────────────────┘  └─────────────────┘  └──────────────┘ │
├─────────────────────────────────────────────────────────────┤
│                  ハードウェア抽象化層                       │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────────┐  ┌─────────────────┐  ┌──────────────┐ │
│  │  IOCSコール     │  │  VRAM管理       │  │  DMA管理     │ │
│  │  (kernel.c)     │  │   (vram.c)      │  │   (dma.c)    │ │
│  └─────────────────┘  └─────────────────┘  └──────────────┘ │
├─────────────────────────────────────────────────────────────┤
│                  プラットフォーム層                         │
├─────────────────────────────────────────────────────────────┤
│  ┌────────────────────────────────────────────────────────┐ │
│  │            Human68K / X68000ハードウェア               │ │
│  └────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
```

### 1.2 CLI 版特有のアーキテクチャ特徴

#### LOCAL_MODE の仕組み

CLI 版は `LOCAL_MODE` マクロによって以下のような動作モードを実現しています：

```c
#ifdef LOCAL_MODE
    // CLI版: Human68K上で実行
    extern void* local_ssos_memory_base;
    extern uint32_t local_ssos_memory_size;
    #define TASK_STACK_SIZE 4096
#else
    // ディスクブート版: ネイティブOSとして実行
    // リンカスクリプトで定義されたメモリレイアウトを使用
#endif
```

#### メモリレイアウト

```
CLI版メモリマップ:
┌─────────────────────────────────────────────────────────────┐
│  Human68K OS領域    (システム予約領域)                      │
├─────────────────────────────────────────────────────────────┤
│  テキストセクション    (コード領域)                         │
├─────────────────────────────────────────────────────────────┤
│  データセクション    (初期化済みデータ)                     │
├─────────────────────────────────────────────────────────────┤
│  BSSセクション      (未初期化データ)                        │
├─────────────────────────────────────────────────────────────┤
│  動的メモリプール    (mallocで確保、10MB)                   │
│  ┌──────────────┐  ┌─────────────┐  ┌─────────────┐         │
│  │タスクスタック│  │ヒープ領域   │  │OSデータ領域 │         │
│  └──────────────┘  └─────────────┘  └─────────────┘         │
└─────────────────────────────────────────────────────────────┘
```

---

## 2. 主要コンポーネント詳細設計

### 2.1 タスク管理システム

#### 2.1.1 タスクコントロールブロック (TCB)

```c
typedef struct _task_control_block {
    void* context;                     // コンテキスト情報
    struct _task_control_block* prev;  // 前のタスク
    struct _task_control_block* next;  // 次のタスク

    // タスク情報
    TaskState state;                   // タスク状態
    FUNCPTR task_addr;                 // タスクエントリポイント
    int8_t task_pri;                   // タスク優先度 (1-8)
    uint8_t* stack_addr;               // スタックアドレス
    int32_t stack_size;                // スタックサイズ

    // ウェイト情報
    TaskWaitFactor wait_factor;        // ウェイト要因
    uint32_t wait_time;                // ウェイト時間
    uint32_t* wait_err;                // ウェイトエラー

    // イベントフラグ情報
    uint32_t wait_pattern;             // ウェイトパターン
    uint32_t wait_mode;                // ウェイトモード
    uint32_t* p_flag_pattern;          // フラグパターン

    // セマフォ情報
    int32_t wait_semaphore;            // セマフォ待ち
} TaskControlBlock;
```

#### 2.1.2 タスク状態遷移図

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   TS_NONEXIST   │───▶│   TS_DORMANT    │───▶│    TS_READY     │
│   (未存在)      │    │   (休止状態)    │    │   (実行可能)    │
└─────────────────┘    └─────────────────┘    └─────────────────┘
                                ▲                      │
                                │                      │
                                │                      ▼
                        ┌─────────────────┐    ┌─────────────────┐
                        │    TS_WAIT      │◀───│   実行状態      │
                        │   (待機状態)    │    │   (Running)     │
                        └─────────────────┘    └─────────────────┘
```

#### 2.1.3 パフォーマンス最適化機能

**割込みバッチ処理**:

```c
// 5回に1回のみコンテキストスイッチ処理を実行
static const uint32_t INTERRUPT_BATCH_SIZE = 5;
static uint32_t interrupt_batch_count = 0;

int timer_interrupt_handler() {
    interrupt_batch_count++;
    global_counter++;

    if (interrupt_batch_count >= INTERRUPT_BATCH_SIZE) {
        interrupt_batch_count = 0;
        if (global_counter % CONTEXT_SWITCH_INTERVAL == 0) {
            return 1;  // コンテキストスイッチ実行
        }
    }
    return 0;  // カウンターのみ更新
}
```

### 2.2 メモリ管理システム

#### 2.2.1 バウンダリタグ合併アルゴリズム

```c
typedef struct {
    uint32_t addr;  // メモリブロック先頭アドレス
    uint32_t sz;    // メモリブロックサイズ
} SsMemFreeBlock;

typedef struct {
    int num_free_blocks;
    SsMemFreeBlock free_blocks[MEM_FREE_BLOCKS];
} SsMemMgr;
```

#### 2.2.2 メモリ確保・解放プロセス

**確保プロセス**:

```
1. サイズチェック (0の場合は即時リターン)
2. ファーストフィット検索
3. 正確なサイズ一致 → ブロックをフリーリストから削除
4. 大きなサイズ → ブロックを分割
5. 残りサイズが0 → ブロックを削除
6. アドレスを返却
```

**解放プロセス**:

```
1. パラメータ検証
2. 挿入位置の決定 (アドレス順)
3. 前方ブロックとの合併チェック
4. 後方ブロックとの合併チェック
5. 三重合併の処理 (前+解放+後)
6. 新規フリーブロックとして挿入
7. フリーブロックテーブル満杯チェック
```

#### 2.2.3 4KB アラインメント最適化

```c
// 4KB境界に合わせたメモリ確保
uint32_t ss_mem_alloc4k(uint32_t sz) {
    if (sz == 0) return 0;
    // サイズを4KB境界に丸める
    sz = (sz + MEM_ALIGN_4K - 1) & MEM_ALIGN_4K_MASK;
    return ss_mem_alloc(sz);
}
```

### 2.3 入力処理システム

#### 2.3.1 構造化キーマッピング

```c
typedef enum {
    KEY_TYPE_NONE,    // 未使用
    KEY_TYPE_FIXED,   // 固定値キー
    KEY_TYPE_LETTER,  // 文字キー
    KEY_TYPE_NUMBER,  // 数字キー
    KEY_TYPE_SYMBOL   // 記号キー
} KeyType;

typedef struct {
    uint8_t scancode;  // スキャンコード
    KeyType type;      // キータイプ
    union {
        struct { uint8_t ascii; } fixed;
        struct { char upper; char lower; } letter;
        struct { char number; char shift_symbol; } number;
        struct { char normal; char shifted; } symbol;
    } value;
} KeyMapping;
```

#### 2.3.2 キーバッファリングシステム

```c
struct KeyBuffer {
    volatile int data[KEY_BUFFER_SIZE];  // キーデータバッファ
    volatile int idxr;                   // 読み込みインデックス
    volatile int idxw;                   // 書き込みインデックス
    volatile int len;                    // 現在の長さ
};

// リアルタイム割込みによるキー入力処理
volatile uint8_t ss_kb_mod_state;  // 修飾キー状態
volatile bool ss_kb_overflowed;    // オーバーフロー状態
```

---

## 3. 実行モードとビルドシステム

### 3.1 デュアルビルドシステム

#### ビルドターゲット

```makefile
# ディスクブート版 (完全なOSとして実行)
make all              # ブートディスクイメージとスタンドアロン版を作成
make clean && make    # 完全再構築

# CLI版 (Human68K上で実行)
make -C standalone    # スタンドアロン実行可能ファイルのみ作成
```

#### コンパイルオプション

```bash
# OSモード (ネイティブ実行)
m68k-xelf-gcc -c input.c -o input.o -I./kernel -I./main -g -O2

# CLIモード (LOCAL_MODE有効)
m68k-xelf-gcc -c input.c -o input.o -I./kernel -I./main -O2 -g -DLOCAL_MODE
```

### 3.2 メモリ管理のモード切替

```c
void ss_get_ssos_memory(void** base, uint32_t* sz) {
#ifdef LOCAL_MODE
    // CLI版: mallocで確保したメモリ領域を使用
    *base = local_ssos_memory_base;  // malloc(10MB)
    *sz = local_ssos_memory_size;    // 10MB
#else
    // OS版: リンカスクリプトで定義されたメモリ領域を使用
    *base = (void*)__ssosram_start;
    *sz = (uint32_t)__ssosram_size;
#endif
}
```

---

## 4. コンポーネント間相互作用

### 4.1 システム初期化シーケンス

```
main() [standalone/main.c]
├── スーパーバイザモード移行
├── 割込みハンドラ設定
├── メモリ情報取得 (テキスト/データ/BSSサイズ)
├── 動的メモリプール確保 (10MB)
└── ssosmain() 呼び出し
    ├── 画面モード設定 (768x512, 16色)
    ├── VRAMクリア
    ├── メモリ管理初期化
    ├── 性能監視初期化
    ├── キーボード初期化
    └── CLIプロセッサ起動
        └── コマンドループ処理
```

### 4.2 タスクスケジューリングフロー

```
タイマー割込み (1ms間隔)
├── global_counter++ (タイムスタンプ更新)
├── バッチカウンター更新 (5回に1回処理)
├── コンテキストスイッチ判定
│   ├── レディーキューから最高優先度タスクを選択
│   ├── 現在タスクと比較
│   ├── コンテキスト保存
│   └── コンテキスト復元
└── 割込み復帰
```

### 4.3 メモリ割り当てフロー

```
アプリケーションメモリ要求
├── ss_mem_alloc() / ss_mem_alloc4k()
├── フリーブロック検索 (ファーストフィット)
├── ブロック分割処理
├── フリーブロックリスト更新
└── アドレス返却
```

---

## 5. パフォーマンス最適化戦略

### 5.1 割込み処理最適化

#### バッチ処理によるオーバーヘッド削減

-   **問題**: 1ms 間隔のタイマー割込みが高頻度で発生
-   **解決**: 5 回に 1 回のみ完全なコンテキストスイッチ処理を実行
-   **効果**: CPU オーバーヘッドを 80%削減しつつタイミング精度を維持

#### 割込みセクションの最小化

```c
// 割込み禁止時間を最小化
disable_interrupts();
// クリティカルセクション (数サイクル)
global_counter++;
enable_interrupts();
```

### 5.2 メモリアクセス最適化

#### キャッシュフレンドリーなデータ構造

```c
// 32bit境界に配置された構造体
typedef struct {
    uint32_t addr;  // 32bit
    uint32_t sz;    // 32bit
} SsMemFreeBlock;
```

#### 効率的なメモリコピー

```c
// 32bit単位のバルクコピーによる最適化
uint32_t* src32 = (uint32_t*)src;
uint32_t* dst32 = (uint32_t*)dst;
for (int j = 0; j < blocks_to_copy; j++) {
    *dst32++ = *src32++;
}
```

### 5.3 キー入力処理最適化

#### ルックアップテーブルによる高速化

```c
// 従来: 50+ caseのswitch文
// 最適化後: O(1)の配列アクセス
static const KeyMapping key_map[] = {
    {0x01, KEY_TYPE_FIXED, .value.fixed = {0x1B}},  // ESC
    {0x02, KEY_TYPE_NUMBER, .value.number = {'1', '!'}},
    // ...
};
```

---

## 6. エラーハンドリングアーキテクチャ

### 6.1 階層的エラー処理システム

```c
typedef enum {
    SS_SEVERITY_INFO,     // 情報
    SS_SEVERITY_WARNING,  // 警告
    SS_SEVERITY_ERROR,    // エラー
    SS_SEVERITY_FATAL     // 致命的エラー
} SsSeverity;

typedef enum {
    SS_ERROR_NONE = 0,
    SS_ERROR_INVALID_PARAM,
    SS_ERROR_OUT_OF_RESOURCES,
    SS_ERROR_NOT_INITIALIZED,
    SS_ERROR_INVALID_STATE
} SsErrorCode;
```

### 6.2 エラーレポーティング機構

```c
void ss_set_error(SsErrorCode code, SsSeverity severity,
                 const char* func, const char* file, int line,
                 const char* message) {
    // エラー情報をグローバルエラーレジスタに記録
    // ファイル名、行番号、関数名を保存
    // デバッグ用の詳細情報を記録
}
```

---

## 7. テストアーキテクチャ

### 7.1 デュアルテスト環境

#### LOCAL_MODE テストフレームワーク

```c
// 軽量テストフレームワーク
#define TEST(name) void test_##name(void)
#define RUN_TEST(name) test_##name()
#define ASSERT_EQ(a, b) /* アサーション実装 */
```

#### メモリテストモック

```c
// LOCAL_MODE時のメモリモック
#ifdef LOCAL_MODE
void* local_ssos_memory_base = test_memory_pool;
uint32_t local_ssos_memory_size = TEST_MEMORY_SIZE;
#endif
```

### 7.2 テストカバレッジ戦略

| テスト対象 | テスト内容                     | カバレッジ |
| ---------- | ------------------------------ | ---------- |
| メモリ管理 | 4KB アラインメント、断片化対策 | 85%        |
| タスク管理 | TCB 操作、スケジューリング     | 70%        |
| 入力処理   | キーマッピング、バッファリング | 60%        |
| CLI        | コマンド処理、入出力           | 40%        |

---

## 8. セキュリティアーキテクチャ

### 8.1 メモリ保護メカニズム

#### 4KB ページ境界による保護

```c
// 4KBアラインメントによるメモリ境界検出
#define MEM_ALIGN_4K_MASK 0xfffff000
uint32_t aligned_addr = addr & MEM_ALIGN_4K_MASK;
```

#### スタック保護

```c
// タスクごとの独立したスタック領域
uint8_t* ss_task_stack_base;  // タスクスタックベース
#define TASK_STACK_SIZE 4096   // 4KBスタック
```

### 8.2 入力検証システム

#### キーコード検証

```c
// スキャンコード範囲チェック
if (scancode > MAX_SCANCODE) {
    return 0;  // 無効なスキャンコード
}
```

#### バッファオーバーフロー対策

```c
// 固定サイズバッファの境界チェック
if (i >= (int)sizeof(command) - 1) {
    break;  // バッファ境界で停止
}
```

---

## 9. 将来拡張性

### 9.1 マイクロカーネル化計画

#### フェーズ 1: サービス分離

-   メモリ管理サービスの分離
-   ファイルシステムサービスの分離
-   デバイスドライバサービスの分離

#### フェーズ 2: メッセージパッシング

```c
// 計画中のメッセージパッシングAPI
typedef struct {
    uint32_t sender_id;
    uint32_t receiver_id;
    uint32_t message_type;
    void* data;
    uint32_t size;
} SsMessage;
```

### 9.2 メモリ保護強化

#### MMU 活用計画

```c
// 計画中のMMU操作API
void ss_mmu_set_page_table(uint32_t* page_table);
void ss_mmu_enable_protection(void);
void ss_mmu_set_readonly(uint32_t addr, uint32_t size);
```

---

## 10. 設計原則とパターン

### 10.1 適用されている設計原則

#### 単一責任の原則

-   各モジュールは明確な単一の責務を持つ
-   タスク管理、メモリ管理、入力処理が分離

#### 開放閉鎖の原則

-   拡張に対して開かれ、修正に対して閉じている
-   新しいタスクタイプの追加が容易
-   新しいキーマッピングの追加が容易

#### 依存関係逆転の原則

-   高レベルモジュールが低レベルモジュールに依存しない
-   IOCS コールによるハードウェア抽象化

### 10.2 設計パターンの適用

#### レイヤードアーキテクチャ

-   明確なレイヤー分割による関心の分離
-   各レイヤーは下位レイヤーにのみ依存

#### ステートパターン

-   タスク状態管理への適用
-   キーボード状態管理への適用

#### ストラテジーパターン

-   メモリ確保戦略の選択（ファーストフィット）
-   スケジューリング戦略の選択（優先度ベース）

---

## 11. 結論と評価

### 11.1 アーキテクチャ評価

#### 強点

1. **明確な階層化**: レイヤードアーキテクチャによる関心の分離
2. **デュアルモード対応**: OS 版と CLI 版のシームレスな切り替え
3. **パフォーマンス最適化**: 68000 アーキテクチャに最適化された実装
4. **拡張性**: モジュール設計による機能追加の容易さ
5. **保守性**: 明確なインターフェースとドキュメンテーション

#### 改善点

1. **CLI 機能の拡張**: 現在の CLI は基本的な機能のみ
2. **テストカバレッジ**: 一部コンポーネントのテストが不足
3. \*\*エラーハンドリング': 一貫性のあるエラー処理が必要

### 11.2 技術的価値

#### 教育的価値

-   組み込み OS のアーキテクチャ学習に最適
-   リアルタイムシステムの実践的な理解
-   ハードウェア抽象化の具体例

#### 実用的価値

-   X68000 プラットフォームでの実用的な OS
-   制約された環境での効率的なリソース管理
-   拡張可能なアーキテクチャによる将来性

### 11.3 今後の展望

#### 短期的目標

-   CLI 機能の拡充 (ファイル操作、プロセス管理)
-   テストカバレッジの向上
-   ドキュメンテーションの充実

#### 長期的目標

-   マイクロカーネル化によるサービス分離
-   ネットワーク機能の追加
-   GUI フレームワークの実装

SSOS CLI 版は、組み込みシステム開発の優れた実装例であり、教育的価値と実用的価値の両方を兼ね備えたアーキテクチャ設計となっています。

---

**文書作成**: Claude AI Assistant
**最終更新**: 2025 年 9 月 29 日
**バージョン**: v1.0
**ライセンス**: SSOS プロジェクトに準拠
